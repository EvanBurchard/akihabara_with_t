<html>
<head>
	<script type="text/javascript" src="akihabara/modernizr-1.5.min.js"></script>
  <script>
    if (Modernizr.canvas === false) {
      window.location = "unsupported.html";
    }
  </script>
	<script type="text/javascript" src="akihabara/gbox.js"></script>
	<script type="text/javascript" src="akihabara/iphopad.js"></script>
	<script type="text/javascript" src="akihabara/trigo.js"></script>
	<script type="text/javascript" src="akihabara/toys.js"></script>
	<script type="text/javascript" src="akihabara/help.js"></script>
	<script type="text/javascript" src="akihabara/tool.js"></script>
	<script type="text/javascript" src="akihabara/gamecycle.js"></script>
	<style>BODY { -webkit-user-select:none; margin:0px}</style>
	<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" />
</head>
<body>
</body>
<script>
// ---
// Copyright (c) 2010 Francesco Cottone, http://www.kesiev.com/
// ---


		  // Game-specific
		  
		  var maingame;
		  var tilemaps={};
		  var dialogues={};
		  var credits={};
		  var noface; // Is a fake "actor" in dialogues. The text is ever in the same place.
		  var audioserver;
		  
		  // In games like Zelda, object are alive also outside of the screen.
		  // So, let's calculate a distance threshold from the camera
		  function objectIsAlive(th) {
		  	return trigo.getDistance(th,gbox.getCamera())<800;
		  }
		  
		  

		  function go() {
		  
		 	gbox.setGroups(["background","player","bonus","foes","walls","playerbullets","foesbullets","sparks","foreground","gamecycle"]);
			gbox.setAudioChannels({bgmusic:{volume:0.8},sfx:{volume:1.0}});
		 	
		 	// player, walls, bullets and foes are under z-index layer
		   	gbox.setRenderOrder(["background",gbox.ZINDEX_LAYER,"sparks","foreground","gamecycle"]);
		  
			maingame=gamecycle.createMaingame("gamecycle","gamecycle");	
		  	
		  	// Title intro
		  maingame.gameTitleIntroAnimation=function(reset) {
			  	if (reset) {
			  		gbox.playAudio("default-music");
			  		toys.resetToy(this,"rising");
		  		} else {
		  			gbox.blitFade(gbox.getBufferContext(),{alpha:1,color:"rgb(150,150,150)"});
		  			toys.logos.rising(this,"rising",{image:"logo",x:gbox.getScreenHW()-gbox.getImage("logo").hwidth,y:20,speed:1,gapx:250,reflex:0.1,audioreach:"coin"});
		  		}
		  	},
		  	 // No level intro animation
		 	 maingame.gameIntroAnimation=function() { return true; }
		 	 // No end level animation
		 	 maingame.endlevelIntroAnimation=function() { return true; }
		 	 // Level animation
		 	 maingame.levelIntroAnimation=function(reset) {
		 	 	if (reset) {
		  			toys.resetToy(this,"default-blinker");
		  		} else {
		  			gbox.blitFade(gbox.getBufferContext(),{alpha:1});
		  			return toys.text.fixed(this,"default-blinker",gbox.getBufferContext(),{font:"big",text:maingame.getNextLevel().label,valign:gbox.ALIGN_MIDDLE,halign:gbox.ALIGN_CENTER,dx:0,dy:0,dw:gbox.getScreenW(),dh:gbox.getScreenH(),time:50});
		  		}
		 	 }
		 	 // Game is ever over, if the player dies the first time. No life check, since is energy-based.
		  	maingame.gameIsOver=function() { return true; }
		  	// Game ending
		  maingame.gameEndingIntroAnimation=function(reset){
		  	if (reset) {
		  		toys.resetToy(this,"intro-animation");
		  	} else {
		  		gbox.blitFade(gbox.getBufferContext(),{alpha:1});
		  		return toys.dialogue.render(this,"intro-animation",credits.titles);
		  	}
		  }
		  	
		  	// Game events are decided by the map.
		  	maingame.gameEvents=function() {
		  		tilemaps.map.mapActions();
		  	}
	
			// Change level
			  maingame.changeLevel=function(level) {
			  	// Cleanup the level
			  	gbox.trashGroup("playerbullets");
			  	gbox.trashGroup("foesbullets");
			  	gbox.trashGroup("foes");
			  	gbox.trashGroup("bonus");
			  	gbox.trashGroup("walls");
			  	gbox.purgeGarbage(); // Since we're starting, we can purge all now
			  	
				if (level==null)
					level={level:"begin",x:300,y:270,introdialogue:false}; // First stage
				
				// Dialogues are emptied - will be loaded by bundles. Cache is not needed - each bundle
				// Contains full dialogues for the floor.
				dialogues={};
				
				// Map data is wiped too. Will be loaded by loadBundle. Other data in tilemaps is
				// kept (i.e. quest status etc)
				delete tilemaps.map;
				
				// Here the map is loaded. During the load time, the game is still.
				gbox.addBundle({
					file:"resources/barerpg/bundle-map-"+level.level+".js",
					onLoad:function(){ // This "onload" operation is triggered after everything is loaded.
						help.finalizeTilemap(tilemaps.map); // Finalize the map into the bundle
						gbox.createCanvas("tileslayer",{w:tilemaps.map.w,h:tilemaps.map.h}); // Prepare map's canvas
						gbox.blitTilemap(gbox.getCanvasContext("tileslayer"),tilemaps.map); // Render map on the canvas
						toys.topview.spawn(gbox.getObject("player","player"),{x:level.x,y:level.y}); // Displace player
					  	tilemaps.map.addObjects(); // Initialize map
					}
				});
			  }
		  
		 	 // Game initialization
	 		  maingame.initializeGame=function() {
	 		  
	 		  	// Prepare hud
				
				tilemaps={
					_defaultblock:100, // The block that is over the borders (a wall)
					queststatus:{} // Every step the player does, is marked here (opened doors, sections cleared etc)
				};
			
				 gbox.addObject({
					id:"bg",
					group:"background",
					blit:function() {
						gbox.centerCamera(gbox.getObject("player","player"),{w:tilemaps.map.w,h:tilemaps.map.h});
						gbox.blit(gbox.getBufferContext(),gbox.getCanvas("tileslayer"),{dx:0,dy:0,dw:gbox.getScreenW(),dh:gbox.getScreenH(),sourcecamera:true});
					},
				  });
			  
				gbox.addObject({
					id:"player",
					group:"player",
					tileset:"player",
					zindex:0, // Needed for zindexed objects
					stilltimer:0, // is used to block the player while attacking (a la zelda!)
					invultimer:0, // Custom attribute. A timer that keep invulnerable.
					isPaused:false, // Pauses the player during dialogues, cutscenes etc.
					
					doPause:function(p) {
						this.isPaused=p;
					},
					
					initialize:function() {
						toys.topview.initialize(this,{
							haspushing:true,
							shadow:{tileset:"shadows",tile:0},
							frames:{
								standup:{ speed:1, frames:[0] },
								standdown:{ speed:1, frames:[3] },
								standleft:{ speed:1, frames:[6] },
								standright:{ speed:1, frames:[6] },
								movingup:{speed:3,frames:[0,1,0,2] },
								movingdown:{speed:3,frames:[3,4,3,5] },
								movingleft:{speed:3,frames:[6,7] },
								movingright:{speed:3,frames:[6,7] },
								pushingup:{speed:6,frames:[0,1,0,2] },
								pushingdown:{speed:6,frames:[3,4,3,5] },
								pushingleft:{speed:6,frames:[6,7] },
								pushingright:{speed:6,frames:[6,7] }
							}
						});
					},
					
					collisionEnabled:function() { // Disable collisions when the game is on hold, the player is dead or invulnerable
						return !maingame.gameIsHold()&&!this.killed&&!this.invultimer&&!this.isPaused;
					},
					
					
					
					
					first:function() {
						if (this.stilltimer) this.stilltimer--;
						if (this.invultimer) this.invultimer--;
						
						// Counter
						this.counter=(this.counter+1)%60;
						if (this.stilltimer||maingame.gameIsHold()||this.isPaused||this.killed)
							toys.topview.controlKeys(this,{}); // Stays still. No key is moving! :)
						else
							toys.topview.controlKeys(this,{left:"left",right:"right",up:"up",down:"down"}); // Moves (if not attacking)
						toys.topview.handleAccellerations(this);
						toys.topview.handleGravity(this); // z-gravity					
						toys.topview.applyForces(this); // Apply forces
						toys.topview.applyGravity(this); // z-gravity
						toys.topview.tileCollision(this,tilemaps.map,"map",tilemaps._defaultblock); // tile collisions
						toys.topview.floorCollision(this); // Collision with the floor (for z-gravity)
						toys.topview.spritewallCollision(this,{group:"walls"}); // Doors and tresaure chests are sprites that acts like a wall.
						toys.topview.adjustZindex(this);
						if (!this.stilltimer&&!this.killed) toys.topview.setFrame(this); // set the right animation frame (if not attacking)
						
						
					},
					blit:function() {
					
						if ((this.invultimer%2)==0) {
							// Shadowed object. First draws the shadow...
							gbox.blitTile(gbox.getBufferContext(),{tileset:this.shadow.tileset,tile:this.shadow.tile,dx:this.x,dy:this.y+this.h-gbox.getTiles(this.shadow.tileset).tileh+4,camera:this.camera});
							// Then the object. Notes that the y is y+z to have the "over the floor" effect.
							gbox.blitTile(gbox.getBufferContext(),{tileset:this.tileset,tile:this.frame,dx:this.x,dy:this.y+this.z,camera:this.camera,fliph:this.fliph,flipv:this.flipv});
						}
					}
	
			  });
			
			};
			
		  gbox.go();
		  
	}
	
	// BOOTSTRAP
	window.addEventListener('load', function () {
		help.akihabaraInit({title:"The Legend Of Sadness",splash:{footnotes:["Musics by: Greenleo, Graulund, Robert Jaret.","Full credits on ending title."]}});

		// We are not going to use faces for dialogues
		noface={ noone:{ x:10, y:170,box:{x:0,y:160,w:gbox.getScreenW(),h:60,alpha:0.5} } };
		
		audioserver="resources/audio/"

		gbox.addBundle({file:"resources/barerpg/bundle.js"}); // Audio, sprites, fonts etc. are loaded here now. Cleaner code! Btw you can still load resources from the code, like in Capman.
		
		gbox.loadAll(go);
	}, false);

	</script>
</html>
